mira tengo que hacer que este codigo mande un socket con la informacion necesaria ademas de un booleano true para que cuando llegue a servidor y luego se lo envie a los demas usuarios se renderice un nuevo avatarcon la informacion de el usuario.
este es mi codigo:
import React, { useContext, useEffect } from 'react';
import { View, StyleSheet, ImageBackground, Text } from 'react-native';
import AcolythCardInHall from '../components/acolyteCardHall.tsx';
import MedievalText from '../components/MedievalText.tsx';
import MapButton from '../components/MapButton.tsx';
import { useNavigation } from '@react-navigation/native';
import { RootStackParamList, StackNavigationProp } from '../types/types.ts';
import { sendIsInHall } from '../sockets/emitEvents.tsx';
import { UserContext, UserContextType } from '../context/UserContext.tsx';
import { sendLocation } from '../sockets/emitEvents.tsx';

type MapScreenNavigationProp = StackNavigationProp<RootStackParamList, 'HallOfSages'>;

interface User {
  _id: string;
  nickname: string;
  avatar: string;
  email: string;
}

const HallOfSages: React.FC = () => {
  const navigation = useNavigation<MapScreenNavigationProp>();
  const context = useContext(UserContext) as UserContextType;
  const { userData } = context;

  // Verifica si los datos de userData existen y están disponibles
  if (!userData || !userData.playerData || !userData.playerData.avatar || !userData.playerData.nickname) {
    return <Text>Cargando...</Text>;  // Si no hay datos de usuario, muestra algo de carga
  }

  // Asigna los datos del usuario actual desde playerData
  const currentUser: User = {
    _id: userData.playerData._id,  // Asegúrate de obtener el _id correcto desde playerData
    nickname: userData.playerData.nickname,  // Accede al nickname
    avatar: userData.playerData.avatar,  // Si no hay avatar, asigna uno predeterminado
    email: userData.playerData.email  // Accede al email
  };

  const goToMap = () => {
    sendLocation('School', userData.playerData.email); // Enviar el email desde playerData
    navigation.navigate('School');
  };

  useEffect(() => {
    // Emite el evento con la información del usuario al unirse a la pantalla
    sendIsInHall();<-------- aqui el socket ocurre al abrir la pantalla
  }, []);

  const renderUserInCircle = () => {
    const radius = 80; // Radio para el avatar
    const centerX = 0;
    const centerY = 0;

    const angle = 0; // Solo un usuario, no necesitamos distribuir en círculo.
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);

    return (
      <View
        key={currentUser._id}
        style={[
          styles.avatarContainer,
          { transform: [{ translateX: x }, { translateY: y }] },
        ]}
      >
        <AcolythCardInHall nickname={currentUser.nickname} avatar={currentUser.avatar} />
      </View>
    );
  };

  return (
    <ImageBackground
      source={require('../assets/obituary.png')}
      style={styles.background}
      resizeMode="cover"
    >
      <View style={styles.titleContainer}>
        <View style={styles.titleBackground} />
        <MedievalText style={styles.title}>Ancestral</MedievalText>
        <MedievalText style={styles.title}>Hall of Sages</MedievalText>
      </View>
      <View style={styles.circleContainer}>{renderUserInCircle()}</View>
      <MapButton
        onPress={goToMap}
        iconImage={require('../assets/school_icon.png')}
      />
    </ImageBackground>
  );
};

const styles = StyleSheet.create({
  background: {
    flex: 1,
    alignItems: 'center',
  },
  titleContainer: {
    position: 'absolute',
    top: 130,
    alignItems: 'center',
  },
  titleBackground: {
    top: -100,
    position: 'absolute',
    backgroundColor: 'rgba(128, 128, 128, 0.7)',
    width: 220,
    height: 120,
    borderRadius: 10,
  },
  title: {
    top: -100,
    fontSize: 35,
    paddingHorizontal: 10,
    paddingVertical: 25,
    textAlign: 'center',
  },
  circleContainer: {
    position: 'absolute',
    top: 300,
    width: 200, // Tamaño reducido para que el avatar quede centrado
    height: 200,
    alignItems: 'center',
    justifyContent: 'center',
  },
  avatarContainer: {
    position: 'absolute',
  },
});

export default HallOfSages;

ademas de eso necesito que el socket se envie desde aqui:
import { Int32 } from 'react-native/Libraries/Types/CodegenTypes';
import socket from './socketConnection';

// Tipamos el parámetro scannedEmail
export const sendQRScan = (scannedEmail: string): void => {
  socket.emit('scan_acolyte', { scannedEmail });
};

export const sendLocation = (location: string, email: string): void => {
  socket.emit('location', location, email);
};

export const sendUserEMail = (email: string) => {
  socket.emit('send_email', { email });
};

export const sendIsInside = (state: boolean): void => {
  console.log('send is inside tower');
  socket.emit('is_inside_tower', { state });
};

export const objectTaken = (objectId: Int32) => {
  console.log("object taken send");
  socket.emit('objectTaken', { id: objectId });
};

export const sendIsInHall = (): void => {
  "este"
};
luego mi parte servidor es asi como te he dicho necesito que se busquen todos los usuarios que en la base de datos tenga isInHall: true y le envie la informacion en un socket se llame send_users_in_hall que se lo mandara a todos los usuarios que esten dentro ademas de eso necesito que me cambie este estado en la base de datos isInHall:

import http from 'http';
import app from './app.js';
import { Server } from 'socket.io';
import './config/mongooseConfig.js';
import { setupSocket } from './services/mqttService.js';
import { mortimerGet, updateLocation } from './services/playerService.js';
import { Player } from './Schemas/PlayerSchema.js';
import { Artefact } from './Schemas/ArtefactSchema.js';
import { config } from 'dotenv';

let deviceLocations = {};

const PORT = process.env.PORT || 3000;
const server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: '*',
    methods: ['GET', 'POST'],
  },
});


io.on('connection', async (socket) => {
  console.log(`Un jugador se ha conectado: ${socket.id}`);

  // Enviar la lista de jugadores (excluyendo los especificados) al cliente que se acaba de conectar
  try {
    const players = await mortimerGet();
    const MORTIMER = await Player.findOne({ email: process.env.MORTIMER_EMAIL });
    const mortimer_socket = MORTIMER?.socketId;

    if (mortimer_socket) {
      socket.to(mortimer_socket).emit('all_players', {
        players: players,
        from: socket.id,
      });
    }
  } catch (error) {
    socket.emit('error', { message: 'Error al obtener la lista de jugadores.' });
  }

  try {
    socket.emit('request_email');

    socket.on('send_email', async (data) => {
      const { email } = data;

      try {
        // Encuentra el usuario y actualiza el socketId
        const user = await Player.findOneAndUpdate(
          { email: email },
          { socketId: socket.id }, // Actualiza el socketId
          { new: true }
        );

        if (user) {
          console.log(`Socket ID actualizado para el usuario: ${email}`);
        } else {
          console.log(`Usuario con email ${email} no encontrado`);
        }
      } catch (error) {
        console.error('Error actualizando el socketId en MongoDB:', error);
      }
    });
  } catch (error) {
    socket.emit('error', { message: 'Error al obtener el correo del jugador' });
  }

  // Escucha el evento 'is_in_hall' para actualizar el estado del jugador
  socket.on('is_in_hall', async (data) => {
    "este"<------------- este de aqui
  });

  // Escucha otros eventos ya definidos
  socket.on('scan_acolyte', async (data) => {
    const { scannedEmail } = data;
    try {
      const acolyte = await Player.findOne({ email: scannedEmail });
      const MORTIMER = await Player.findOne({ email: process.env.MORTIMER_EMAIL });
      const acolyte_socket = acolyte?.socketId;
      const mortimer_socket = MORTIMER?.socketId;

      if (!acolyte) {
        return socket.emit('error', { message: 'Acolyte no encontrado' });
      }

      // Cambiar el estado del Acolyte
      acolyte.is_active = !acolyte.is_active;
      await acolyte.save();
      const players = await mortimerGet();

      if (mortimer_socket) {
        socket.to(mortimer_socket).emit('all_players', {
          players: players,
          from: socket.id,
        });
      }

      // Enviar el estado actualizado al cliente
      socket.emit('acolyte_status_updated', {
        success: true,
        email: acolyte.email,
        is_active: acolyte.is_active,
        message: `Acolyte ahora está ${acolyte.is_active ? 'online' : 'offline'}`,
      });

      // Notificar al Acolyte que fue escaneado
      if (acolyte_socket) {
        socket.to(acolyte_socket).emit('qr_scanned', {
          is_active: acolyte.is_active,
        });

        socket.to(acolyte_socket).emit('change_isInside', {
          data: acolyte.is_active,
          from: socket.id,
        });
      }

      console.log(
        `Estado del Acolyte actualizado: ${acolyte.email} - ${
          acolyte.is_active ? 'online' : 'offline'
        }`
      );
    } catch (error) {
      console.error('Error al cambiar el estado del Acolyte:', error);
      socket.emit('error', { message: 'Error al cambiar el estado del Acolyte' });
    }
  });

  socket.on('is_inside_tower', () => {
    console.log('Se ha recibido un evento is_inside_tower');
    if (process.env.ENABLE_MQTT === 'true') {
      console.log("cerrando puerta");
      mqttClient.publish('EIASAcolyteInside', `mesage`);
    }
  });

  socket.on('location', (location, email) => {
    console.log(`location change for ${email} to :${location}`);
    updateLocation(email, location);
  });

  socket.on('objectTaken', async (data) => {
    const objectId = data.id;
    console.log(`Objeto tomado con ID: ${objectId}`);

    try {
      // Actualizar el campo isTaken en la base de datos
      const updatedartefact = await Artefact.findOneAndUpdate(
        { id: objectId },
        { isTaken: true },
        { new: true }
      );

      if (updatedartefact) {
        console.log(`POI con ID ${objectId} actualizado en MongoDB`);

        // Opcional: Emitir un evento a todos los clientes para actualizar el estado del objeto
        io.emit('poiUpdated', { id: objectId, isTaken: true });
        io.emit('update_artifacts');
      } else {
        console.log(`No se encontró POI con ID ${objectId}`);
      }
    } catch (error) {
      console.error('Error al actualizar el POI en MongoDB:', error);
    }
  });

  socket.on('restore_objects', async () => {
    try {
      // Actualiza todos los artefactos en la base de datos
      await Artefact.updateMany({}, { isTaken: false });

      console.log("All objects restored to isTaken: false");
      io.emit('update_artifacts');
    } catch (error) {
      console.error("Error restoring objects:", error);
    }
  });

  // Escuchar el evento de solicitud de artefactos
  socket.on('request_artifacts', async () => {
    try {
      const artifacts = await Artefact.find(); // Obtener todos los artefactos de la base de datos
      socket.emit('receive_artifacts', artifacts); // Enviar artefactos al cliente
    } catch (error) {
      console.error("Error fetching artifacts:", error);
    }
  });

  // Ubicación de los dispositivos
  socket.on('locationUpdate', (data) => {
    const { userId, coords, avatar } = data;
    deviceLocations[userId] = { coords, avatar }; // Guardar ubicación por ID de usuario
  
    // Broadcast location to all clients
    io.emit('deviceLocations', deviceLocations);
  });

  socket.on('disconnect', () => {
    console.log(`Jugador desconectado: ${socket.id}`);
  });
});

// Inicializar MQTT si está habilitado
let mqttClient = null;

if (process.env.ENABLE_MQTT === 'true') {
  (async () => {
    const { default: mqttClientModule } = await import('./config/mqttConfig.js');
    mqttClient = mqttClientModule;

    const { setupSocket } = await import('./services/mqttService.js');
    setupSocket(io, mqttClient);
  })();
}

server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});

el socket que se envie se recivira aqui en una constante que se exportara a el archivo inicial que es donde se renderizaran todos los usuarios recividos:

import { Alert, Vibration,ToastAndroid } from 'react-native';
import socket from './socketConnection';
import Config from 'react-native-config';
import { useContext } from 'react';
import { UserContext } from '../context/UserContext';

// Función para escuchar eventos del servidor
export const listenToServerEvents = (): void => {
  socket.on('response', (data: { message: string }) => {
    Alert.alert('Server Response', data.message);
  });

  socket.on('alert', (data: { message: string }) => {
    Alert.alert('Server Alert', data.message);
  });

};

// Función para escuchar eventos del servidor y actualizar el estado de los jugadores
export const listenToServerEventsMortimer = (updatePlayers: (players: any) => void): void => {
  socket.on('all_players', (data: { players: any }) => {
    console.log('Jugadores recibidos del servidor:', data.players);
    updatePlayers(data.players); // Llamamos a la función de actualización con los jugadores
  });
};

// Función para escuchar eventos del servidor y actualizar el estado de los jugadores
export const listenToServerEventsScanAcolyte = (setIsInside: (is_active: any) => void): void => {
  socket.on('change_isInside', (data: { data: any }) => {
    console.log('Valor de is_active:', data);
    Vibration.vibrate(1000);
    setIsInside(data.data); // Llamamos a la función de actualización con los jugadores
  });
};

// Función para escuchar eventos del servidor y actualizar 
export const listenToServerEventsAcolyte = (email: any,setIsInsideTower: (is_active: any) => void ): void => {
  socket.on('door_status', (data: any) => {
    console.log('door open');
    Vibration.vibrate(1000);
    showToastWithGravityAndOffset();
    sendNotification(email);
    setIsInsideTower(data.isOpen);
  });
};

// Función para escuchar eventos del servidor y actualizar el estado de los jugadores
export const listenToServerEventsDoorOpened = (setIsDoorOpen: (isOpen: boolean) => void): void => {
  socket.on('door_status', (data: { data: boolean }) => {
    console.log('Valor de door_status:', data.data);
    Vibration.vibrate(1000);
    setIsDoorOpen(data.data); // Activa el estado solo si se abre la puerta
  });
};

export const listenToPlayerStatusUpdated <------------ en esta const


// Función para limpiar los eventos cuando el componente se desmonte
export const clearServerEvents = (): void => {
  socket.off('response');
  socket.off('alert');
  socket.off('all_players');
  socket.off('change_isInside');
  socket.off('qr_scanned');
  socket.off('pushNotification');
  socket.off('door_status');
};



const sendNotification = async (email:any) => {
  console.log('Sending notification with email:', email);

  try {
    const response = await fetch(`${Config.RENDER}/api/notifications/send-notification`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email }),
    });

    if (!response.ok) {
      throw new Error('Network response was not ok');
    }

    const data = await response.json();
    console.log('Server response:', data);
  } catch (error) {
    console.error('Error:', error);
  }
};

 async function checkIfInsideTower(email: any) {
  try {
    console.log('FEtchint');
    const response = await fetch(`${Config.RENDER}/api/auth/isInsideTower`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email }),
    });

    if (!response.ok) {
      throw new Error('Error al verificar si esta dentro');
    }

    const data = await response.json();
    console.log('Respuesta del servidor:', data.is_inside_tower); // Puedes verificar la respuesta aquí
    return data.is_inside_tower;
  } catch (error) {
    console.error('Error al verificar si el usuario está dentro de la torre:', error);
    return null;
  }
}


const showToastWithGravityAndOffset = () => {
  ToastAndroid.showWithGravityAndOffset(
    'Puerta abierta',
    ToastAndroid.LONG,
    ToastAndroid.BOTTOM,
    25,
    50,
  );
};

